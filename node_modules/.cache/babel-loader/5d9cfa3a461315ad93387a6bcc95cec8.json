{"ast":null,"code":"import equal from '@gilbarbara/deep-equal';\nimport is from 'is-lite';\nexport function canHaveLength() {\n  var arguments_ = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    arguments_[_i] = arguments[_i];\n  }\n\n  return arguments_.every(function (d) {\n    return is.string(d) || is.array(d) || is.plainObject(d);\n  });\n}\nexport function checkEquality(left, right, value) {\n  if (!isSameType(left, right)) {\n    return false;\n  }\n\n  if ([left, right].every(is.array)) {\n    return !left.some(hasValue(value)) && right.some(hasValue(value));\n  }\n  /* istanbul ignore else */\n\n\n  if ([left, right].every(is.plainObject)) {\n    return !Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value));\n  }\n\n  return right === value;\n}\nexport function compareNumbers(previousData, data, options) {\n  var actual = options.actual,\n      key = options.key,\n      previous = options.previous,\n      type = options.type;\n  var left = nested(previousData, key);\n  var right = nested(data, key);\n  var changed = [left, right].every(is.number) && (type === 'increased' ? left < right : left > right);\n\n  if (!is.undefined(actual)) {\n    changed = changed && right === actual;\n  }\n\n  if (!is.undefined(previous)) {\n    changed = changed && left === previous;\n  }\n\n  return changed;\n}\nexport function compareValues(previousData, data, options) {\n  var key = options.key,\n      type = options.type,\n      value = options.value;\n  var left = nested(previousData, key);\n  var right = nested(data, key);\n  var primary = type === 'added' ? left : right;\n  var secondary = type === 'added' ? right : left; // console.log({ primary, secondary });\n\n  if (!is.nullOrUndefined(value)) {\n    if (is.defined(primary)) {\n      // check if nested data matches\n      if (is.array(primary) || is.plainObject(primary)) {\n        return checkEquality(primary, secondary, value);\n      }\n    } else {\n      return equal(secondary, value);\n    }\n\n    return false;\n  }\n\n  if ([left, right].every(is.array)) {\n    return !secondary.every(isEqualPredicate(primary));\n  }\n\n  if ([left, right].every(is.plainObject)) {\n    return hasExtraKeys(Object.keys(primary), Object.keys(secondary));\n  }\n\n  return ![left, right].every(function (d) {\n    return is.primitive(d) && is.defined(d);\n  }) && (type === 'added' ? !is.defined(left) && is.defined(right) : is.defined(left) && !is.defined(right));\n}\nexport function getIterables(previousData, data, _a) {\n  var _b = _a === void 0 ? {} : _a,\n      key = _b.key;\n\n  var left = nested(previousData, key);\n  var right = nested(data, key);\n\n  if (!isSameType(left, right)) {\n    throw new TypeError('Inputs have different types');\n  }\n\n  if (!canHaveLength(left, right)) {\n    throw new TypeError(\"Inputs don't have length\");\n  }\n\n  if ([left, right].every(is.plainObject)) {\n    left = Object.keys(left);\n    right = Object.keys(right);\n  }\n\n  return [left, right];\n}\nexport function hasEntry(input) {\n  return function (_a) {\n    var key = _a[0],\n        value = _a[1];\n\n    if (is.array(input)) {\n      return equal(input, value) || input.some(function (d) {\n        return equal(d, value) || is.array(value) && isEqualPredicate(value)(d);\n      });\n    }\n    /* istanbul ignore else */\n\n\n    if (is.plainObject(input) && input[key]) {\n      return !!input[key] && equal(input[key], value);\n    }\n\n    return equal(input, value);\n  };\n}\nexport function hasExtraKeys(left, right) {\n  return right.some(function (d) {\n    return !left.includes(d);\n  });\n}\nexport function hasValue(input) {\n  return function (value) {\n    if (is.array(input)) {\n      return input.some(function (d) {\n        return equal(d, value) || is.array(value) && isEqualPredicate(value)(d);\n      });\n    }\n\n    return equal(input, value);\n  };\n}\nexport function includesOrEqualsTo(previousValue, value) {\n  return is.array(previousValue) ? previousValue.some(function (d) {\n    return equal(d, value);\n  }) : equal(previousValue, value);\n}\nexport function isEqualPredicate(data) {\n  return function (value) {\n    return data.some(function (d) {\n      return equal(d, value);\n    });\n  };\n}\nexport function isSameType() {\n  var arguments_ = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    arguments_[_i] = arguments[_i];\n  }\n\n  return arguments_.every(is.array) || arguments_.every(is.number) || arguments_.every(is.plainObject) || arguments_.every(is.string);\n}\nexport function nested(data, property) {\n  /* istanbul ignore else */\n  if (is.plainObject(data) || is.array(data)) {\n    /* istanbul ignore else */\n    if (is.string(property)) {\n      var props = property.split('.');\n      return props.reduce(function (acc, d) {\n        return acc && acc[d];\n      }, data);\n    }\n    /* istanbul ignore else */\n\n\n    if (is.number(property)) {\n      return data[property];\n    }\n\n    return data;\n  }\n\n  return data;\n} //# sourceMappingURL=helpers.js.map","map":null,"metadata":{},"sourceType":"module"}